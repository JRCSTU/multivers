#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
"""
Python-2.7-safe, no-deps code to discover sub-project versions in Git *polyvers* monorepos.

The *polyvers* version-configuration tool is generating **pvtags** like::

    proj-foo-v0.1.0

And assuming :func:`polyversion()` is invoked from within a Git repo, it may return
either ``0.1.0`` or ``0.1.0+2.gcaffe00``, if 2 commits have passed since
last *pvtag*.

Also the wheel is executable like that::

    python polyversion-*.whl --help

"""
from __future__ import print_function

import sys

import os.path as osp


#: A 2-tuple containing 2 ``{vprefix}`` values for the patterns below,for
#: for *version-tags* and *release-tags* respectively.
tag_vprefixes = ('v', 'r')

#: The default pattern for *monorepos* version-tags,
#: receiving 3 :pep:`3101` interpolation parameters::
#:
#:     {pname}, {version} = '*', {vprefix} = tag_vprefixes[0 | 1]
#:
#: The match patterns for ``git describe --match <pattern>`` are generated by this.
pvtag_format = '{pname}-{vprefix}{version}'
#: Like :data:`pvtag_format` but for *mono-project* version-tags.
vtag_format = '{vprefix}{version}'

#: The default regex pattern breaking *monorepo* version-tags
#: and/or ``git-describe`` output into 3 capturing groups:
#:
#:   - ``pname``,
#:   - ``version`` (without the ``{vprefix)``),
#:   - ``descid`` (optional) anything following the dash('-') after
#:     the version in ``git-describe`` result.
#:
#: It is given 2 :pep:`3101` interpolation parameters::
#:
#:     {pname}, {vprefix} = tag_vprefixes[0 | 1]
#:
#: See :pep:`0426` for project-name characters and format.
pvtag_regex = r"""(?xmi)
    ^(?P<pname>{pname})
    -
    {vprefix}(?P<version>\d[^-]*)
    (?:-(?P<descid>\d+-g[a-f\d]+))?$
"""
#: Like :data:`pvtag_format` but for *mono-project* version-tags.
vtag_regex = r"""(?xmi)
    ^(?P<pname>)
    {vprefix}(?P<version>\d[^-]*)
    (?:-(?P<descid>\d+-g[a-f\d]+))?$
"""


def clean_cmd_result(res):  # type: (bytes) -> str
    """
    :return:
        only if there is something in `res`, as utf-8 decoded string
    """
    res = res and res.strip()
    if res:
        return res.decode('utf-8', errors='surrogateescape')


def rfc2822_tstamp(nowdt=None):
    """Py2.7 code from https://stackoverflow.com/a/3453277/548792"""
    from datetime import datetime
    import time
    from email import utils

    if nowdt is None:
        nowdt = datetime.now()
    nowtuple = nowdt.timetuple()
    nowtimestamp = time.mktime(nowtuple)
    now = utils.formatdate(nowtimestamp, localtime=True)

    return now


def _my_run(cmd, cwd):
    import subprocess as sbp

    "For commands with small output/stderr."
    if not isinstance(cmd, (list, tuple)):
        cmd = cmd.split()
    proc = sbp.Popen(cmd, stdout=sbp.PIPE, stderr=sbp.PIPE,
                     cwd=str(cwd), bufsize=-1)
    res, err = proc.communicate()

    if proc.returncode != 0:
        print('%s\n  cmd: %s' % (err, cmd), file=sys.stderr)
        raise sbp.CalledProcessError(proc.returncode, cmd)
    else:
        return clean_cmd_result(res)


def _caller_module(nframes_back=2):
    import inspect

    frame = inspect.currentframe()
    try:
        for _ in range(nframes_back):
            frame = frame.f_back
        modname = frame.f_globals['__name__']
        name = modname.split('.')[-1]
        if name.startswith('_'):  # eg: _version, __init__, __main__
            raise ValueError(
                "Auto-derived project-name from module '%s' starts with underscore!" %
                modname)
        return name
    finally:
        del frame


def _caller_fpath(nframes_back=2):
    import inspect

    frame = inspect.currentframe()
    try:
        for _ in range(nframes_back):
            frame = frame.f_back
        fpath = inspect.getframeinfo(frame).filename

        return osp.dirname(fpath)
    finally:
        del frame


def split_pvtag(pvtag, pvtag_regex):
    try:
        m = pvtag_regex.match(pvtag)
        if not m:
            raise ValueError(
                "Unparseable *pvtag* from `pvtag_regex`!")
        mg = m.groupdict()
        return mg['pname'], mg['version'], mg['descid']
    except Exception as ex:
        print("Matching pvtag '%s' failed due to: %s" %
              (pvtag, ex), file=sys.stderr)
        raise


def version_from_descid(version, descid):
    """
    Combine ``git-describe`` parts in a :pep:`440` version with "local" part.

    :param: version:
        anythng after the project and ``'-v`'`` i,
        e.g it is ``1.7.4.post0``. ``foo-project-v1.7.4.post0-2-g79ceebf8``
    :param: descid:
        the part after the *pvtag* and the 1st dash('-'), which must not be empty,
        e.g it is ``2-g79ceebf8`` for ``foo-project-v1.7.4.post0-2-g79ceebf8``.
    :return:
        something like this: ``1.7.4.post0+2.g79ceebf8`` or ``1.7.4.post0``
    """
    assert descid, (version, descid)
    local_part = descid.replace('-', '.')
    return '%s+%s' % (version, local_part)


def _interp_fnmatch(tag_format, pname, is_release=False):
    return tag_format.format(pname=pname,
                             version='*',
                             vprefix=tag_vprefixes[int(is_release)])


def _interp_regex(tag_regex, pname, is_release=False):
    return tag_regex.format(pname=pname,
                            vprefix=tag_vprefixes[int(is_release)])


def polyversion(**kw):
    """
    Report the *pvtag* of the `pname` in the git repo hosting the source-file calling this.

    :param str pname:
        The project-name, used as the prefix of pvtags when searching them.
        If not given, defaults to the *last segment of the module-name of the caller*.

        .. Attention::
           when calling it from ``setup.py`` files, auto-deduction above
           will not work;  you must supply a project name.
    :param str default_version:
        What *version* to return if git cmd fails.
        Set it to `None` to raise if no *vtag* found.

        .. Tip::
           For cases where a shallow git-clone does not finds any *vtags*
           back in history, or simply because the project is new, and
           there are no *vtags*, we set default-version to empty-string,
           to facilitate pip-installing these projects from sources.

    :param str repo_path:
        A path inside the git repo hosting the `pname` in question; if missing,
        derived from the calling stack.
    :param bool mono_project:
      - false: (default) multiple sub-projects per git-repo.
        Tags formatted by *pvtags* :data:`pvtag_format` & :data:`pvtag_regex`
        (like ``pname-v1.2.3``).
      - true: only one project in git-repo
        Tags formatted as *vtags* :data:`vtag_format` & :data:`vtag_regex`.
        (like ``v1.2.3``).
    :param str tag_format:
        The :pep:`3101` pattern for creating *pvtags* (or *vtags*).

        - It receives 2 parameters to interpolate: ``{pname}, {version} = '*'``.
        - It is used also to generate the match patterns for ``git describe --match <pattern>``
          command.
        - It overrides `mono_project` arg.
        - See :data:`pvtag_format` & :data:`vtag_format`
    :param regex tag_regex:
        The regex pattern breaking apart *pvtags*, with 3 named capturing groups:

        - ``pname``,
        - ``version`` (without the 'v'),
        - ``descid`` (optional) anything following the dash('-') after
          the version in ``git-describe`` result.

        - It is given a :pep:`3101` parameter ``{pname}`` to interpolate.
        - It overrides `mono_project` arg.
        - See :pep:`0426` for project-name characters and format.
        - See :data:`pvtag_regex` & :data:`vtag_regex`
    :param git_options:
        List of options(str) passed to ``git describe`` command.
    :return:
        The version-id derived from the *pvtag*, or `default` if
        command failed/returned nothing, unless None, in which case, it raises.
    :raise:
        if it cannot find t=any vtag (e.g. no git cmd/repo, no valid tags)

    .. Tip::
        It is to be used, for example, in package ``__init__.py`` files like this::

            __version__ = polyversion()

        Or from any other file::

            __version__ = polyversion('myproj')

    .. Note::
       This is a python==2.7 & python<3.6 safe function; there is also the similar
       function with elaborate error-handling :func:`polyvers.pvtags.descrivbe_project()`
       in the full-blown tool `polyvers`.
    """
    pname = kw.get('pname')
    default_version = kw.get('default_version')
    repo_path = kw.get('repo_path')
    mono_project = kw.get('mono_project')
    tag_format = kw.get('tag_format')
    tag_regex = kw.get('tag_regex')
    git_options = kw.get('git_options', ())

    version = None

    if not pname:
        pname = _caller_module()

    if tag_format is None:
        tag_format = vtag_format if mono_project else pvtag_format
    if tag_regex is None:
        tag_regex = vtag_regex if mono_project else pvtag_regex
    if not repo_path:
        repo_path = _caller_fpath()
        if not repo_path:
            repo_path = '.'

    import re

    tag_pattern = _interp_fnmatch(tag_format, pname)
    tag_regex = re.compile(_interp_regex(tag_regex, pname))
    try:
        cmd = 'git describe'.split()
        cmd.extend(git_options)
        cmd.append('--match=' + tag_pattern)
        pvtag = _my_run(cmd, cwd=repo_path)
        matched_project, version, descid = split_pvtag(pvtag, tag_regex)
        if matched_project and matched_project != pname:
            #import traceback as tb
            #tb.print_stack()
            print("Matched  pvtag project '%s' different from expected '%s'!" %
                  (matched_project, pname), file=sys.stderr)
        if descid:
            version = version_from_descid(version, descid)
    except:  # noqa;  E722"
        if default_version is None:
            raise

    if not version:
        version = default_version

    return version


def polytime(**kw):
    """
    The timestamp of last commit in git repo hosting the source-file calling this.

    :param str no_raise:
        If true, never fail and return current-time
    :param str repo_path:
        A path inside the git repo hosting the project in question; if missing,
        derived from the calling stack.
    :return:
        the commit-date if in git repo, or now; :rfc:`2822` formatted
    """
    no_raise = kw.get('no_raise', False)
    repo_path = kw.get('repo_path')

    cdate = None
    if not repo_path:
        repo_path = _caller_fpath()
    cmd = "git log -n1 --format=format:%cD"
    try:
            cdate = _my_run(cmd, cwd=repo_path)
    except:  # noqa;  E722
        if not no_raise:
            raise

    if not cdate:
        cdate = rfc2822_tstamp()

    return cdate


__version__ = '0.1.0a0'
__updated__ = '2018-05-31T05:55:51.281987'


def run(*args):
    """
    Describe the version of a *polyvers* projects from git tags.

    USAGE:
        %(prog)s [PROJ-1] ...
        %(prog)s [-v | -V ]     # print my version information

    See http://polyvers.readthedocs.io

    :param argv:
        Cmd-line arguments, nothing assumed if nothing given.

    - Invokes :func:`polyversion.run()` with ``sys.argv[1:]``.
    - In order to set cmd-line arguments, invoke directly the function above.
    - With a single project, it raises any problems (e.g. no tags).
    """
    import os

    for o in ('-h', '--help'):

        if o in args:
            import textwrap as tw

            cmdname = osp.basename(sys.argv[0])
            doc = tw.dedent('\n'.join(run.__doc__.split('\n')[1:7]))
            print(doc % {'prog': cmdname})
            return 0

    if '-v' in args:
        print(__version__, end='')
        return 0
    if '-V' in args:
        print("version: %s\nupdated: %s" % (__version__, __updated__))
        return 0

    if len(args) == 1:
        res = polyversion(pname=args[0], repo_path=os.curdir)
    else:
        res = '\n'.join('%s: %s' % (p, polyversion(pname=p,
                                                   default_version='',
                                                   repo_path=os.curdir))
                        for p in args)

    if res:
        print(res)


##############
## `setup.py` keywords
#
#  Idea & some code borrowed from BSDlicensed *pbr* tool:
#      https://github.com/openstack-dev/pbr/blob/master/pbr/packaging.py
#

def _get_version_from_pkg_metadata(package_name):
    """Get the version from package metadata if present.

    This looks for PKG-INFO if present (for sdists), and if not looks
    for METADATA (for wheels) and failing that will return None.
    """
    import email

    pkg_metadata_filenames = ['PKG-INFO', 'METADATA']
    pkg_metadata = {}
    for filename in pkg_metadata_filenames:
        try:
            pkg_metadata_file = open(filename, 'r')
        except (IOError, OSError):
            continue
        try:
            pkg_metadata = email.message_from_file(pkg_metadata_file)
        except email.errors.MessageError:
            continue

    # Check to make sure we're in our own dir
    if pkg_metadata.get('Name', None) != package_name:
        return None
    return pkg_metadata.get('Version', None)


class SetupKeyword(object):
    """
    New *setuptools* kwd to find subproject version from PKG-INFO or git tags.

    The value to this keyword can be a boolean, or a dictionary with keys
    roughly mimicing those in :func:`polyversion()`:

    :ivar bool version_scheme:
        A string-label selecting versioning scheme:
          - monorepo: (default) multiple sub-projects per git-repo.
            Tags formatted by *pvtags* :data:`pvtag_format` & :data:`pvtag_regex`
            (like ``pname-v1.2.3``).
          - mono-project:
            Tags formatted as *vtags* :data:`vtag_format` & :data:`vtag_regex`.
            (like ``v1.2.3``).

        The `tag_format` and `tag_regex` args take precendance, if given.
    :ivar str tag_format:
        The :pep:`3101` pattern for creating *pvtags* (or *vtags*).
          - It may interpolate 2 parameters: ``{pname}, {version} = '*'``.
          - It is used also to generate the match patterns for
            command ``git describe --match <pattern>``.
          - It overrides `version_scheme` arg.
          - See :data:`pvtag_format` & :data:`vtag_format`
    :ivar regex tag_regex:
        The regex pattern breaking apart *pvtags*, with 3 named capturing groups:
          - ``pname``,
          - ``version`` (without the 'v'),
          - ``descid`` (optional) anything following the dash('-') after
            the version in ``git-describe`` result.

          - It is given a :pep:`3101` parameter ``{pname}`` to interpolate.
          - It overrides `version_scheme` arg.
          - See :pep:`0426` for project-name characters and format.
          - See :data:`pvtag_regex` & :data:`vtag_regex`
    :ivar git_options:
        List of options(str) passed to ``git describe`` command.

    - First it tries to see if project contained in a distribution-archive
      (e.g. a "wheel"), and tries to derive the version from egg-infos.
      Then it falls through retrieving it from git tags.

    - The standard ``setup(version=<version>)`` keyword is passed in as
      the value to ``polyversion.polyversion(default_version=<version>)``.

      So if ``version`` is a (possibly empty) string, this will be used in case
      version cannot be auto-retrived.

      If ``version`` is omitted (or it is `None`), any problems will be raised,
      and setup.script wil abort

      .. Tip::
          For cases where a shallow git-clone does not finds any *vtags*
          back in history, or simply because the project is new, and
          there are no *vtags*, we set default-version to empty-string,
          to facilitate pip-installing these projects from sources.
    """
    # Registered in `distutils.setup_keywords` *entry_point* of this project's
    #``setup.py``.

    __slots__ = ('version_scheme tag_format '
                 'tag_regex git_options'.split())

    def __init__(self, dist, attr, value):
        from distutils.errors import DistutilsSetupError

        if value is False:
            return
        elif value is True:
            value = {}

        good_keys = SetupKeyword.__slots__
        try:
            for k in set(good_keys) | set(value):
                setattr(self, k, value.get(k))
        except Exception:
            raise DistutilsSetupError(
                "`%s` must be boolean or a dict mapping!"
                "\n available keys: %s\n  got: %r" %
                (attr, ', '.join(good_keys), value))

        if self.version_scheme not in (None, 'monorepo', 'mono-project'):
            raise DistutilsSetupError(
                "`%s.version_scheme` must be one of ('monorepo' | 'mono-project', got: %r)" %
                (attr, self.version_scheme))

        if self.git_options and not isinstance(self.git_options, (tuple, list)):
            raise DistutilsSetupError(
                "`%s.git_options` must be an iterable (got: %r)" %
                (attr, self.git_options))

        pname = dist.metadata.name
        version = _get_version_from_pkg_metadata(pname)
        if not version:
            version = polyversion(
                pname=pname,
                ## In case we cannot derrive version, use one provided by user (if any).
                default_version=dist.metadata.version or '',
                mono_project=self.version_scheme == 'mono-project',
                tag_format=self.tag_format,
                tag_regex=self.tag_regex,
                git_options=self.git_options or (),

                repo_path=osp.abspath('.'),
            )

        dist.metadata.version = version
